/*
원시 타입
- Number, String, Boolean 등 …
- 값 자체로써 변수에 저장되고 복사 된다
- 불변값이다 
- 불변값이다 (메모리 값 수정 O)

객체 타입
- Object, Array, Function 등 …
- 참조값을 통해 변수에 저장되고 복사 된다
- 가변값이다 (메모리 값 수정 X)
*/

/*
객체 타입 주의사항 1.
의도치 않게 값이 수정될 수 있다.
*/

/*
- 객체는 '값'이 아니라 '참조값'이 변수에 저장된다.
- 따라서 o1과 o2는 같은 객체를 바라보게 된다.
- 그 결과, o2를 수정하면 o1도 영향을 받아 값이 변경된다.
*/

// 예제 1: 참조값을 그대로 복사
let o1 = { name: "이예린" };
let o2 = o1; // o1의 참조값을 o2에 복사 (같은 객체를 가리킴)
o2.name = "홍길동"; // o2를 수정했지만, 실제 같은 객체이므로 o1도 함께 수정됨

console.log(o1.name); // "홍길동"
console.log(o2.name); // "홍길동"

/*
- 전개 연산자(...)를 사용하면 새로운 객체가 만들어진다.
- 따라서 s1과 s2는 서로 다른 참조값을 가진다.
- 이 경우 s2.name을 변경해도 s1.name에는 영향이 없다.
*/

// 예제 2: 전개 연산자(...)를 사용한 복사
let s1 = { name: "이예린" };
let s2 = { ...s1 }; // s1의 속성을 펼쳐 새로운 객체를 생성 (얕은 복사)
s2.name = "홍길동"; // s2만 수정됨 (s1은 영향을 받지 않음)

console.log(s1.name); // "이예린"
console.log(s2.name); // "홍길동"

/*
객체 타입 주의사항 2.
객체간의 비교는 기본적으로 참조값을 기준으로 이루어진다.
*/

let a1 = { name: "예린" };
let a2 = a1; // 같은 참조값을 가리킴 (a1과 a2는 동일 객체)
let a3 = { ...a1 }; // 새로운 객체를 생성 (a1과는 다른 참조값)

// === 연산자 비교
console.log(a1 === a2); // true  (같은 객체를 참조)
console.log(a1 === a3); // false (내용은 같아도 참조는 다름)

// 단순 비교시 객체는 참조 기준이라 값이 같아도 false가 나옴
console.log(a1, a3);
// { name: "예린" } { name: "예린" }  (겉보기엔 같아도 내부 참조값은 다름)

// 따라서 보통 "값"을 비교하려면 stringify를 활용함
console.log(JSON.stringify(a1) === JSON.stringify(a3)); // true (내용이 같음을 비교 가능)

/*
정리:
- a1 === a2 → true  (참조 같음)
- a1 === a3 → false (내용 같아도 참조 다름)
- JSON.stringify(a1) === JSON.stringify(a3) → true (문자열화 후 값 비교)
*/
